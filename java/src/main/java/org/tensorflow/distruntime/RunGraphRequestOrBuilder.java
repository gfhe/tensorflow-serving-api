// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/protobuf/worker.proto

package org.tensorflow.distruntime;

public interface RunGraphRequestOrBuilder extends
    // @@protoc_insertion_point(interface_extends:tensorflow.RunGraphRequest)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * session_handle is the master-generated unique id for this session.
   * If session_handle is non-empty, it must be the same as used when
   * registering the graph. If it is empty, a single global namespace is used to
   * search for the graph_handle.
   * </pre>
   *
   * <code>string session_handle = 8;</code>
   * @return The sessionHandle.
   */
  java.lang.String getSessionHandle();
  /**
   * <pre>
   * session_handle is the master-generated unique id for this session.
   * If session_handle is non-empty, it must be the same as used when
   * registering the graph. If it is empty, a single global namespace is used to
   * search for the graph_handle.
   * </pre>
   *
   * <code>string session_handle = 8;</code>
   * @return The bytes for sessionHandle.
   */
  com.google.protobuf.ByteString
      getSessionHandleBytes();

  /**
   * <pre>
   * Set to true if `CreateWorkerSession` was called for `session_handle`.
   * </pre>
   *
   * <code>bool create_worker_session_called = 10;</code>
   * @return The createWorkerSessionCalled.
   */
  boolean getCreateWorkerSessionCalled();

  /**
   * <pre>
   * REQUIRED: graph_handle must be returned by a RegisterGraph call
   * to the same WorkerService.
   * </pre>
   *
   * <code>string graph_handle = 1;</code>
   * @return The graphHandle.
   */
  java.lang.String getGraphHandle();
  /**
   * <pre>
   * REQUIRED: graph_handle must be returned by a RegisterGraph call
   * to the same WorkerService.
   * </pre>
   *
   * <code>string graph_handle = 1;</code>
   * @return The bytes for graphHandle.
   */
  com.google.protobuf.ByteString
      getGraphHandleBytes();

  /**
   * <pre>
   * A unique ID to distinguish different runs of the same graph.
   * The master generates a global unique `step_id` to distinguish
   * different runs of the graph computation. Subgraphs communicate
   * (e.g., send/recv ops) with each other using `step_id` to
   * distinguish tensors generated by different runs.
   * </pre>
   *
   * <code>int64 step_id = 2;</code>
   * @return The stepId.
   */
  long getStepId();

  /**
   * <pre>
   * Options for this step.
   * </pre>
   *
   * <code>.tensorflow.ExecutorOpts exec_opts = 5;</code>
   * @return Whether the execOpts field is set.
   */
  boolean hasExecOpts();
  /**
   * <pre>
   * Options for this step.
   * </pre>
   *
   * <code>.tensorflow.ExecutorOpts exec_opts = 5;</code>
   * @return The execOpts.
   */
  org.tensorflow.distruntime.ExecutorOpts getExecOpts();
  /**
   * <pre>
   * Options for this step.
   * </pre>
   *
   * <code>.tensorflow.ExecutorOpts exec_opts = 5;</code>
   */
  org.tensorflow.distruntime.ExecutorOptsOrBuilder getExecOptsOrBuilder();

  /**
   * <pre>
   * Runs the graph.
   * Sends the tensors in "send" into the graph before the run and
   * fetches the keys into `RunGraphResponse.recv` after the run.
   * </pre>
   *
   * <code>repeated .tensorflow.NamedTensorProto send = 3;</code>
   */
  java.util.List<org.tensorflow.framework.NamedTensorProto> 
      getSendList();
  /**
   * <pre>
   * Runs the graph.
   * Sends the tensors in "send" into the graph before the run and
   * fetches the keys into `RunGraphResponse.recv` after the run.
   * </pre>
   *
   * <code>repeated .tensorflow.NamedTensorProto send = 3;</code>
   */
  org.tensorflow.framework.NamedTensorProto getSend(int index);
  /**
   * <pre>
   * Runs the graph.
   * Sends the tensors in "send" into the graph before the run and
   * fetches the keys into `RunGraphResponse.recv` after the run.
   * </pre>
   *
   * <code>repeated .tensorflow.NamedTensorProto send = 3;</code>
   */
  int getSendCount();
  /**
   * <pre>
   * Runs the graph.
   * Sends the tensors in "send" into the graph before the run and
   * fetches the keys into `RunGraphResponse.recv` after the run.
   * </pre>
   *
   * <code>repeated .tensorflow.NamedTensorProto send = 3;</code>
   */
  java.util.List<? extends org.tensorflow.framework.NamedTensorProtoOrBuilder> 
      getSendOrBuilderList();
  /**
   * <pre>
   * Runs the graph.
   * Sends the tensors in "send" into the graph before the run and
   * fetches the keys into `RunGraphResponse.recv` after the run.
   * </pre>
   *
   * <code>repeated .tensorflow.NamedTensorProto send = 3;</code>
   */
  org.tensorflow.framework.NamedTensorProtoOrBuilder getSendOrBuilder(
      int index);

  /**
   * <code>repeated string recv_key = 4;</code>
   * @return A list containing the recvKey.
   */
  java.util.List<java.lang.String>
      getRecvKeyList();
  /**
   * <code>repeated string recv_key = 4;</code>
   * @return The count of recvKey.
   */
  int getRecvKeyCount();
  /**
   * <code>repeated string recv_key = 4;</code>
   * @param index The index of the element to return.
   * @return The recvKey at the given index.
   */
  java.lang.String getRecvKey(int index);
  /**
   * <code>repeated string recv_key = 4;</code>
   * @param index The index of the value to return.
   * @return The bytes of the recvKey at the given index.
   */
  com.google.protobuf.ByteString
      getRecvKeyBytes(int index);

  /**
   * <pre>
   * True if the RunGraphRequest is a partial run request.
   * </pre>
   *
   * <code>bool is_partial = 6;</code>
   * @return The isPartial.
   */
  boolean getIsPartial();

  /**
   * <pre>
   * True if this is the last partial run request in a sequence of requests.
   * </pre>
   *
   * <code>bool is_last_partial_run = 7;</code>
   * @return The isLastPartialRun.
   */
  boolean getIsLastPartialRun();

  /**
   * <pre>
   * If true then some errors, e.g., execution errors that have long
   * error messages, may return an OK RunGraphResponse with the actual
   * error saved in the status_code/status_error_message fields of the
   * response body. This is a workaround since the RPC subsystem may
   * truncate long metadata messages.
   * </pre>
   *
   * <code>bool store_errors_in_response_body = 9;</code>
   * @return The storeErrorsInResponseBody.
   */
  boolean getStoreErrorsInResponseBody();

  /**
   * <pre>
   * Unique identifier for this request. Every RunGraphRequest must have a
   * unique request_id, and retried RunGraphRequests must have the same
   * request_id. If request_id is zero, retry detection is disabled.
   * Retried RunGraphRequests are problematic because they may issue a
   * RecvTensor that will have no corresponding sender and will wait forever.
   * Workers use request_ids to reject retried RunGraph requests instead of
   * waiting forever.
   * </pre>
   *
   * <code>int64 request_id = 11;</code>
   * @return The requestId.
   */
  long getRequestId();
}
